{"version":3,"file":"ng-fallimg.js.map","sources":["ng://ng-fallimg/lib/ng-fallimg-sources.ts","ng://ng-fallimg/lib/ng-fallimg.directive.ts","ng://ng-fallimg/lib/ng-fallimg.module.ts"],"sourcesContent":["/**\n * Injector token constant that contains all the fallback sources \n */\n\nexport const NG_FALLIMG_SOURCES = 'NG_FALLIMG_SOURCES';\n\n/**\n * Interface that define the object to pass to charged the fallback sources\n */\n\nexport interface IFallimgSource {\n    default: string;\n    [extraProps: string]: string\n}\n","import { Directive, ElementRef, Input, HostListener, Inject } from '@angular/core';\nimport { NG_FALLIMG_SOURCES, IFallimgSource } from './ng-fallimg-sources';\n\n/**\n * Directive for handling the default image when the main image doesn't works\n */\n\n@Directive({\n  selector: 'img[fallimg]'\n})\nexport class NgFallimgDirective {\n\n  /**\n   * Input that receive an optional key for returning the source\n   */\n\n  @Input('fallimg') public fallimg: string;\n\n  /**\n   * It contains the last source setted when the main source fails\n   */\n\n  private lastSource: string;\n\n  /**\n   * \n   * @param el ElementRef service\n   * @param fallimgSources Injector token that contains all the fallback sources\n   */\n\n  constructor(\n    private el: ElementRef,\n    @Inject( NG_FALLIMG_SOURCES ) private fallimgSources: IFallimgSource\n  ) {}\n\n  /**\n   * It handles the error when the main image doesn't load\n   */\n\n  @HostListener('error')\n  private errorImgHandler(): void {\n\n    // The chosen source\n    const source = this.fallimgSources[ this.fallimg || 'default' ];\n\n    // Verify if the key exists in all fallback sources\n    if (!source) {\n      throw new Error(`ng-fallimg error: ${ this.fallimg } doesn't exist as a source or it is an empty source`);\n    }\n\n    // it checks if the charged source is different to the actual source, this avoid the infinite bucle creation\n    if (source !== this.lastSource) {\n\n      // It saves the last source for matching when the fallback source fails and retried, that avoid an infinite bucle\n      this.lastSource = source;\n      (this.el.nativeElement as HTMLImageElement).src = source;\n      \n    }\n  }\n}\n","import { NgModule, ModuleWithProviders } from '@angular/core';\nimport { NgFallimgDirective } from './ng-fallimg.directive';\nimport { NG_FALLIMG_SOURCES, IFallimgSource } from './ng-fallimg-sources';\n\n@NgModule({\n  declarations: [NgFallimgDirective],\n  exports: [NgFallimgDirective]\n})\nexport class NgFallimgModule { \n  \n  /**\n   * @param sources All the fallback sources\n   */\n  \n  static forRoot(sources: IFallimgSource): ModuleWithProviders {\n    return {\n      ngModule: NgFallimgModule,\n      providers: [\n        {\n          provide: NG_FALLIMG_SOURCES,\n          useValue: sources\n        }\n      ]\n    };\n  }\n}\n"],"names":[],"mappings":";;;;;;;;;;AAIA,MAAa,kBAAkB,GAAG,oBAAoB;;;;;;ACJtD;;;AAUA,MAAa,kBAAkB;;;;;;IAoB7B,YACU,EAAc,EACgB,cAA8B;QAD5D,OAAE,GAAF,EAAE,CAAY;QACgB,mBAAc,GAAd,cAAc,CAAgB;KAClE;;;;;;IAOI,eAAe;;;cAGf,MAAM,GAAG,IAAI,CAAC,cAAc,CAAE,IAAI,CAAC,OAAO,IAAI,SAAS,CAAE;;QAG/D,IAAI,CAAC,MAAM,EAAE;YACX,MAAM,IAAI,KAAK,CAAC,qBAAsB,IAAI,CAAC,OAAQ,qDAAqD,CAAC,CAAC;SAC3G;;QAGD,IAAI,MAAM,KAAK,IAAI,CAAC,UAAU,EAAE;;YAG9B,IAAI,CAAC,UAAU,GAAG,MAAM,CAAC;YACzB,oBAAC,IAAI,CAAC,EAAE,CAAC,aAAa,IAAsB,GAAG,GAAG,MAAM,CAAC;SAE1D;KACF;;;YAnDF,SAAS,SAAC;gBACT,QAAQ,EAAE,cAAc;aACzB;;;;YATmB,UAAU;4CAgCzB,MAAM,SAAE,kBAAkB;;;sBAhB5B,KAAK,SAAC,SAAS;8BAuBf,YAAY,SAAC,OAAO;;;;;;;ACvCvB,MAQa,eAAe;;;;;IAM1B,OAAO,OAAO,CAAC,OAAuB;QACpC,OAAO;YACL,QAAQ,EAAE,eAAe;YACzB,SAAS,EAAE;gBACT;oBACE,OAAO,EAAE,kBAAkB;oBAC3B,QAAQ,EAAE,OAAO;iBAClB;aACF;SACF,CAAC;KACH;;;YApBF,QAAQ,SAAC;gBACR,YAAY,EAAE,CAAC,kBAAkB,CAAC;gBAClC,OAAO,EAAE,CAAC,kBAAkB,CAAC;aAC9B;;;;;;;;;;;;;;;"}
